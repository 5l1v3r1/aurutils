#!/bin/bash
# aur-search - search for AUR packages
set -o pipefail
readonly argv0=search
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

# default options
multiple=section
query_type=search
search_by=name-desc
sort_key=Name

tabulate() {
    # XXX Add missing fields (depends, makedepends, checkdepends)
    jq -r --arg key "$1" '[.results[]] | sort_by(.[$key])[] | [
        .Name,
        .PackageBase,
        .Version,
        .Description,
        .URL,
        (.Keywords  // ["(null)"] | join(" ")),
        (.License   // ["(null)"] | join(" ")),
        .NumVotes,
        .Popularity,
        .Maintainer // "-",
        .OutOfDate  // "-",
        (.FirstSubmitted | todate),
        (.LastModified   | todate)
    ] | @tsv'
}

parse_long() {
    local -a desc=(
        'Name'
        'Base'
        'Version'
        'Description'
        'URL'
        'Keywords'
        'License'
        'Votes'
        'Popularity'
        'Maintainer'
        'Out Of Date'
        'Submitted'
        'Last Modified'
    )
    local -a info

    # XXX use some less bash-heavy way here
    while IFS=$'\t' read -r -a info; do
        for i in "${!info[@]}"; do
            printf -- '%s:\t%s\n' "${desc[i]}" "${info[i]}"
        done
    done
}

parse_short() {
    local Name Version NumVotes Maintainer OutOfDate Description

    while IFS=$'\t' read -r Name _ Version Description _ _ _ NumVotes _ Maintainer OutOfDate _ _; do
        case $OutOfDate in
            -) unset OutOfDate ;;
            *) # XXX move date command to jq (must only be run if OutOfDate is set)
               OutOfDate="(Out-of-date: $(date -d @"$OutOfDate" '+%d %B %Y'))" ;;
        esac

        case $Maintainer in
            -) Maintainer='(Orphaned)' ;;
            *) unset Maintainer ;;
        esac

        printf "${BLUE}aur/${ALL_OFF}${BOLD}%s ${GREEN}%s ${ALL_OFF}(%s) ${RED}%s %s${ALL_OFF}\\n    %s\\n" \
               "$Name" "$Version" "$NumVotes" "$Maintainer" "$OutOfDate" "$Description"
    done
}

usage() {
    printf -- >&2 'usage: %s: [-aimnrv] [-k key] package [package...]\n' "$argv0"
    exit 1
}

source /usr/share/makepkg/util/message.sh || exit

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

unset format
while getopts :aisdmnqvk: opt; do
    case $opt in
        a) multiple=union       ;;
        i) query_type=info      ;;
        s) query_type=search    ;;
        d) search_by=name-desc  ;;
        m) search_by=maintainer ;;
        n) search_by=name       ;;
        q) format=short         ;;
        v) format=long          ;;
        k) sort_key=$OPTARG     ;;
        *) usage                ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

if ((!$#)); then
    usage
fi

# XXX union is done by the AUR for info type, but not search
if (($# < 2)) || [[ $query_type == info ]]; then
    multiple=none
fi

# set format depending on query type (#319)
case $query_type in
      info) format=${format-long}  ;;
    search) format=${format-short} ;;
esac

# set filters
case $format in
     # XXX no canonical way for column (util-linux) to respect empty lines?
     long) parse() { parse_long | column -ts $'\t' | sed '0~13 a\\'; } ;;
    short) parse() { parse_short; } ;;
esac

case $multiple in
    section) combine() { sort | uniq -d; } ;;
      union) combine() { sort | uniq -u; } ;;
       none) combine() { tee; } ;;
esac

# pipeline
printf -- '%s\n' "$@" | aur rpc -t "$query_type" -b "$search_by" | tabulate "$sort_key" | combine | parse

# vim: set et sw=4 sts=4 ft=sh:
