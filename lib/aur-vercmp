#!/bin/bash
# shellcheck disable=SC2209
readonly argv0=vercmp
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -o pipefail

declare    format=all target=aur
declare -i all=0

cmp_equal_or_newer() {
    while read -r pkg v_cmp v_in; do
        if [[ -n $v_in ]]; then
            op=$(my_vercmp "$v_in" "$v_cmp")
        else
            return 1
        fi

        case $op in
            1) msg2 "$pkg: $v_cmp -> $v_in" ;;
            0) printf -- '%s\n' "$pkg" ;;
           -1) plain "$pkg: $v_cmp is newer than $v_in"
               printf -- '%s\n' "$pkg" ;;
        esac
    done
}
readonly -f cmp_equal_or_newer

cmp_checkupdates() {
    while read -r pkg v_cmp v_in; do
        if [[ -n $v_in ]]; then
            op=$(my_vercmp "$v_in" "$v_cmp")
        else
            return 1
        fi

        case $op in
            0|1) ((!all)) && continue ;;
        esac

        case $op in
            1) printf -- '%s: %s <- %s\n' "$pkg" "$v_in" "$v_cmp" ;;
            0) printf -- '%s: %s = %s\n'  "$pkg" "$v_in" "$v_cmp" ;;
           -1) printf -- '%s: %s -> %s\n' "$pkg" "$v_in" "$v_cmp" ;;
        esac
    done
}
readonly -f cmp_checkupdates

my_vercmp() {
    if [[ $1 != "$2" ]]; then
        vercmp "$1" "$2"
    else
        printf '%d' 0
    fi
}
readonly -f my_vercmp

parse_aur() {
    aur rpc -t info | jq -r '.results[] | [.Name, .Version] | @tsv'
}
readonly -f parse_aur

parse_sync() {
    pacconf --repo="$1" >/dev/null || return

    pacsift --repo="$1" --exact <&- | xargs -r \
        pacman -Sddp --print-format '%n %v'
}
readonly -f parse_sync

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}
readonly -f trap_exit

usage() {
    plain "usage: $argv0 [-d repo] [-p file] [-ac]"
    exit 1
}
readonly -f usage

source /usr/share/makepkg/util/message.sh || exit

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

unset aux_p repo
while getopts :acd:p: opt; do
    case $opt in
        a) all=1         ;;
        c) format=equal  ;;
        d) repo=$OPTARG  ;;
        p) target=file
           aux_p=$OPTARG ;;
        *) usage         ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

tmp=$(mktemp) || exit
trap 'trap_exit' EXIT

# set input file
if [[ -v repo ]]; then
    parse_sync "$repo" | sort -k 1b,1 >"$tmp"
else
    if [[ -t 0 ]]; then
        plain 'repository not specified, assuming stdin'
    fi
    sort -k 1b,1 >"$tmp"
fi

# set filters (1)
case $target in
     aur) get() { awk '{print $1}' "$tmp" | parse_aur; } ;;
    file) get() { awk '{print $0}' "$aux_p"; } ;;
esac

# set filters (2)
case $format in
      all) cmp() { cmp_checkupdates;   } ;;
    equal) cmp() { cmp_equal_or_newer; } ;;
esac

# XXX no third field if stdin is empty (ifne?)
get | sort -k 1b,1 | join -a 2 -e 'N/A' -o auto - "$tmp" | cmp

# vim: set et sw=4 sts=4 ft=sh:
