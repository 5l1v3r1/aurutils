#!/bin/bash
# aur-repo - manage local repositories

## functions - query database directly
conf_file_repo() {
    awk -F'= ' '
        $1 ~ /^\[.+\]$/ {
            repo = substr($1, 2, length($1)-2)
        }
        $1 ~ /^Server/ && $2 ~ /^file:/ {
            printf("%s\n%s\n", repo, $2)
        }'
}

db_namever() {
    awk '/%NAME%/ {
        getline
        printf("%s\t", $1)
    }
    /%VERSION%/ {
        getline
        printf("%s\n", $1)
    }'
}

db_fill_empty() {
    awk '{print} END {
        if (!NR)
            printf("%s\t%s\n", "(none)", "(none)")
    }'
}

db_cat() {
    bsdcat "$1" | db_namever | db_fill_empty
}

db_tsv() {
    local pkgname pkgver
    
    while read -r pkgname pkgver; do
        printf '%q %s %s\n' "$db_name" "$pkgname" "$pkgver"
    done
}

## functions - query pacman sync database
check_sync() {
    # https://github.com/andrewgregory/pacutils/issues/22
    pacconf --repo="$1" >/dev/null || return 1
}

parse_sync() {
    # https://git.archlinux.org/pacman.git/commit/?id=ab3d8478
    pacsift --exact --null --repo "$1" <&- \
        | xargs -0r pacman -Sddp --print-format '%r %n %v'
}

## functions - auxiliary
usage() {
    plain "usage: $argv0 [-elpu] [--path] [-d repo] [-r root]"
    exit 1
}

source /usr/share/makepkg/util/message.sh
source /usr/share/makepkg/util/parseopts.sh

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

## option parsing
opt_short='d:r:elpu'
opt_long=('enum' 'list' 'pacman' 'database:' 'repo:' 'root:' 'path' 'update')

if ! parseopts "$opt_short" "${opt_long[@]}" -- "$@"; then
    usage
fi
set -- "${OPTRET[@]}"

unset mode db_name db_root db_path
while true; do
    case $1 in
	-d|--database|--repo)
	    shift; db_name=$1 ;;
	-e|--enum)
	    mode=enum_repo ;;
	-l|--list)
	    mode=list_repo ;;
	-r|--root)
	    shift; db_root=$1 ;;
	-p|--pacman)
	    mode=list_pacman ;;
	-u|--update)
	    mode=list_pacman_updates ;;
	--path)
	    mode=print_path ;;
	--) shift; break ;;
    esac
    shift
done
unset opt_short opt_long OPTRET

if ! [[ -v mode ]]; then
    usage
fi

## local repo selection
if [[ -n ${db_name=$AUR_REPO} ]]; then
    if [[ -z ${db_root=$AUR_DBROOT} ]]; then
	db_root=$(pacconf --single --repo="$db_name" Server)
	db_root=${db_root#*://}
    fi
else
    mapfile -t conf < <(pacconf | conf_file_repo)

    case ${#conf[@]} in
        2) db_name=${conf[0]}
           db_root=${conf[1]#*://} ;;
        0) error "$argv0: no file:// repository found"
           exit 2 ;;
        *) error "$argv0: repository choice is ambiguous (use --repo to specify)"
           printf '%s\n' "${conf[@]}" | paste - - | column -t >&2
           exit 2 ;;
    esac
fi

db_path=$(realpath -e -- "$db_root/$db_name".db) # .db symbolic link to archive
db_root=$(realpath -e -- "$db_root")

## actions
case $mode in
    enum_repo)
	db_cat "$db_path" | db_tsv
	;;
    list_pacman)
	check_sync "$db_name" || exit

	parse_sync "$db_name"
	;;
    list_pacman_updates)
	check_sync "$db_name" || exit

	parse_sync "$db_name" | aur vercmp
	;;
    list_repo)
	pacconf | conf_file_repo
	;;
    print_path)
	printf '%s\n' "$db_path"
	;;
esac
