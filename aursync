#!/bin/bash
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -e -o pipefail

argv0=aursync
aurweb=https://aur.archlinux.org
tarpath=$aurweb/cgit/aur.git/snapshot
tmp=$(mktemp -d)

XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
AURDEST=${AURDEST:-$XDG_CACHE_HOME/$argv0}

readonly argv0 aurweb rpc tarpath tmp XDG_CACHE_HOME AURDEST

confirm() {
    local -l reply
    local message prompt
    local bias=$1; shift

    case $bias in
        yes) prompt=Y/n ;;
        no)  prompt=y/N ;;
    esac

    printf -v message -- "$BOLD* $1 [$prompt]$ALL_OFF " "${@:2}"
    read -rp "$message" reply

    case $bias in
        yes) [[ $reply = y || ! $reply ]] ;;
        no)  [[ $reply = y ]] ;;
    esac
}

inspect() {
    if confirm yes 'View build files?'; then
        xargs -a "$1" -i find {} -maxdepth 1 | vifm - '+view!'
    fi
}

check() {
    git fetch -v

    if [[ $(git rev-parse HEAD) != $(git rev-parse @{upstream}) ]]; then
        msg2 "changes found: $1"
        git --no-pager log --oneline --stat ..@{upstream}

        if confirm no 'Merge?'; then
            git merge
        fi
    fi
}

clone() {
    while read -r base; do
        ( if cd "$base" 2>/dev/null; then
              check "$base"
          else
              git clone "$aurweb/$base".git
          fi
	)
    done
}

snapshot() {
    awk -v uri=$tarpath '{
        gsub("+","%2b"); gsub("@","%40");
        printf "%s/%s.tar.gz\n", uri, $1
    }' | aria2c -s 16 -x 16 -j 32 -d "$tmp" -i -

    mkdir -p snapshot

    for ar in "$tmp"/*.tar.gz; do
        tar xvf "$ar" -C snapshot
    done
}

prepare() {
    declare key val source vcs base name ver rel syncver

    while read -r source; do
	case $(get_protocol "$source") in
	    bzr*|git*|hg*|svn*)
		vcs=1
		break;;
	esac
    done < <(awk '/source/ {print $3}' .SRCINFO)

    if ((vcs)); then
	makepkg --verifysource --nobuild >/dev/null
	makepkg --printsrcinfo > .SRCINFO
    fi
    
    while read -r key _ val; do
	case "$key" in
	    pkgbase) base="$val";;
	    pkgname) name+=("$val");;
	    pkgver)  ver="$val";;
	    pkgrel)  rel="$val";;
	esac
    done < .SRCINFO

    # Read the first match (split packages are built together)
    read -r syncver < <(expac -1 -S '%v' "${name[@]}") || :

    if [[ ! $syncver ]] || (($(vercmp "$ver-$rel" "$syncver") == 1)); then
        msg "$base: $syncver -> $ver-$rel"
        printf '%s\n' "$base"
    elif (($(vercmp "$ver-$rel" "$syncver") == -1)); then
	warning "$base: $ver-$rel <- $syncver"
    else
        msg "$base is up-to-date"
    fi
}

prepare_all() {
    if ((noprepare)); then
        tee
    else    
	while read -r pkg; do
	    ( cd "$pkg"
	      prepare "$pkg"
	    )
	done
    fi
}

repofind() {
    #global target pool
    declare repo path
    declare -A rset

    while {
        read -r repo
        read -r _ _ path
    } do
        if [[ $path =~ ^file:// ]]; then
            rset[$repo]=${path#file://}
        fi
    done < <(pacconf --single | awk '/^\[/ && !/options/ || /Server/ {gsub(/[][]/,""); print}')

    if [[ ${rset[@]} ]]; then
        if ((${#rset[@]} > 1)); then
            select target in "${!rset[@]}"; do
                break
            done
        else
            target=${!rset[*]}
        fi

        msg "Using [$target] repository"
        pool=${rset[$target]}
    else
        error "No file:// repository found"
        exit 2
    fi

    if [[ ! -d $pool ]] || [[ ! -w $pool ]]; then
	error "$pool: Not a directory"
	exit 1
    fi
}

quickcheck() {
    #global target
    declare pkg ver siftargs str="$aurweb/rpc.php/rpc/?v=5&type=info"
    declare -A set_l set_r

    if (($#)); then
	for pkg; do siftargs+=(--name="$pkg"); done
    fi

    if repofind; then
	while read -r pkg ver; do
	    set_l[$pkg]=$ver
	done < <(pacsift --repo="$target" "${siftargs[@]}" | expac -S '%n %v' -)
    fi

    if [[ ! ${set_l[@]} ]]; then
	error "No packages available"
	exit
    fi
    
    for p in "${!set_l[@]}"; do
	str+="&arg[]=$p"
    done

    while read -r pkg ver; do
	set_r[$pkg]=$ver
    done < <(curl --retry 3 -sSgL "$str" | jshon -e results -a -e Name -u -p -e Version -u | xargs -n2)

    for p in "${!set_r[@]}"; do
	if (($(vercmp "${set_r[$p]}" "${set_l[$p]}") == 1)); then
	    printf '%s\n' "$p ${set_l[$p]} -> ${set_r[$p]}"
	fi
    done
}

trap 'rm -rf "$tmp"' EXIT

source /usr/share/makepkg/util.sh

[[ -t 2 ]] && colorize

while getopts :clfRtu OPT; do
    case $OPT in
        c|+c) aurbuild_args+=(-c) ;;
	f|+f) aurbuild_args+=(-f)
	      noprepare=1         ;;
        l|+l) resolve=aurqueue
              download=/bin/true  ;;
	R|+R) aurbuild_args+=(-R) ;;
        t|+t) download=snapshot   ;;
	u|+u) update=1            ;;
        *)    plain "usage: $argv0 [+-clfRtu} [--] ARGS..."
              exit 1 ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

if ((update)); then
    quickcheck "$@"; exit
fi

# Operations are done in the cache directory, unless said otherwise.
cd "$AURDEST"

if "${resolve:-aurchain}" "$@" | tee "$tmp"/q | "${download:-clone}"; then
    inspect "$tmp"/q
 
    if grep -Fxf <(prepare_all < "$tmp"/q) "$tmp"/q > "$tmp"/q_new; then
        if repofind; then
            aurbuild_args+=(-d "$target".db -r "$pool" -p "$pool")
            aurbuild "${aurbuild_args[@]}" "$tmp"/q_new
        fi
    fi
fi
