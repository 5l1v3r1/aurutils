#!/bin/bash
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -o pipefail

argv0=aursearch
aurweb="https://aur.archlinux.org"
cache="${XDG_CACHE_HOME:-$HOME/.cache}/$argv0"
tmp=$(mktemp -dt "$argv0".XXXXXXXXXX) || exit

readonly argv0 aurweb cache tmp

# Default options
declare -i nameonly=0 string=0 raw=0 verbose=0
declare list=packages

# $1: .gz archive (URI)
# $2: .gz archive (name)
fetch() {
    if curl -sS "$1" -o "$2"; then
        gunzip -f "$2"
    else
        exit
    fi
}

# $1: .gz archive (URI)
sync_list() {
    declare gz=${1##*/}
    declare li=${gz%.*}

    declare stamp_l stamp_r epoch_l epoch_r

    if [[ -f $li ]]; then
        # Use HTTP date to compare the generation date (first line).
        # https://bugs.archlinux.org/task/49092
        read -r stamp_l < <(awk -F', ' '{print $3; exit}' "$li")
        read -r stamp_r < <(curl -fsSI "$1" | awk -F', ' '/^Date:/ {print $2}')

        read -r epoch_l < <(date -d "$stamp_l" '+%s')
        read -r epoch_r < <(date -d "$stamp_r" '+%s')

        # The update interval is set to 5 minutes by default.
        # https://lists.archlinux.org/pipermail/aur-dev/2016-May/004036.html
        if ((epoch_r - epoch_l > 300)); then
            fetch "$1" "$gz"
        fi
    else
        fetch "$1" "$gz"
    fi
}

# The actual "match" is done by aurweb; as such, string is similar
# to grep --fixed-strings.
match() {
    #global string
    if ((string)); then
        printf '%s\n' "${@:2}"
    else
        sync_list "$aurweb/$1".gz || return

        # Remove the generation date before matching.
        if ! grep -P -- "$2" <(tail -n +2 "$1"); then
            error "$argv0: no matches found"
            exit 1
        fi
    fi
}

# Split by 150 arguments to prevent HTTP 414.
# https://bugs.archlinux.org/task/49089
split() {
    awk -v rpc="$aurweb/rpc/?v=5&type=info" '{
        # URL encode @ and +
        gsub("+","%2b")
        gsub("@","%40")

        if (NR == 1 || (NR % 150) == 0)
            printf "\n%s&arg[]=%s", rpc, $0
        else
            printf "&arg[]=%s", $0
    }'
}

getjson() {
    if aria2c --download-result=hide --console-log-level=error --stderr=true -d "$tmp" -i -; then
        # If stdin is empty, aria reports "No files to download" and
        # returns 0. When -i or -Z are set, the file name can not be changed.
        [[ ! -s "$tmp"/index.html ]] && return

        # Merge to a single JSON structure, see jshon(1).
        awk '{print}' "$tmp"/index.html* | sed -e '1i[' -e '$!s/$/,/' -e '$a]' > "$tmp"/raw

        # Check for results, only print if non-zero (#96)
        case $(jshon -F "$tmp"/raw -a -e resultcount -u) in
            0) error "$argv0: no matches found"
               exit 1 ;;
            *) cat "$tmp"/raw ;;
        esac
    else
        exit $?
    fi
}

brief() {
    while {
        read -r Name
        read -r Version
        read -r NumVotes
        read -r Description
    }; do
        # libmakepkg misses PURPLE and CYAN
        printf "${BLUE}aur/${ALL_OFF}${BOLD}%s ${GREEN}%s ${ALL_OFF}(%s)\n    %s\n" \
               "$Name" "$Version" "$NumVotes" "$Description"
        # The RPC fills empty fields with "null", removing the need for jshon -C.
    done < <(jshon -Q -a -e results -a -e Name -u -p -e Version \
                   -u -p -e NumVotes -u -p -e Description -u)
}

long() {
    while {
        read -r Name
        read -r PackageBase
        read -r Version
        read -r Description
        read -r URL
        read -r NumVotes
        read -r Popularity
        read -r OutOfDate
        read -r Maintainer
        read -r FirstSubmitted
        read -r LastModified
    }; do
        printf "Name:            %s\n" "$Name"
        printf "Base:            %s\n" "$PackageBase"
        printf "Version:         %s\n" "$Version"
        printf "Description:     %s\n" "$Description"
        printf "URL:             %s\n" "$URL"
        printf "Votes:           %s\n" "$NumVotes"
        printf "Popularity:      %s\n" "$Popularity"
        printf "Out Of Date:     %s\n" "$OutOfDate"
        printf "Maintainer:      %s\n" "$Maintainer"
        printf "First Submitted: %s\n" "$(date -d @"$FirstSubmitted" '+%c')"
        printf "Last Modified:   %s\n" "$(date -d @"$LastModified" '+%c')"
        printf '%s\n'
    done < <(jshon -Q -a -e results -a -e Name -u -p -e PackageBase -u -p -e Version \
                   -u -p -e Description -u -p -e URL -u -p -e NumVotes -u -p -e Popularity \
                   -u -p -e OutOfDate -u -p -e Maintainer -u -p -e FirstSubmitted \
                   -u -p -e LastModified -u)
}

parse() {
    #global raw verbose
    if ((raw)); then
        tee
    elif ((verbose)); then
        long
    else
        brief
    fi
}

trap 'rm -rf "$tmp"' EXIT

source /usr/share/makepkg/util.sh || exit

[[ -t 2 ]] && colorize

while getopts :Fbqruv OPT; do
    case $OPT in
        F|+F) string=1     ;;
        b|+b) list=pkgbase ;;
        q|+q) nameonly=1   ;;
        r|+r) raw=1        ;;
        v|+v) verbose=1    ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

# Operations are done in the cache directory, unless said otherwise.
mkdir -p "$cache"
chmod -c 700 "$cache"
cd "$cache" || exit

if ((!$#)); then
    plain "$argv0: no targets specified"
    exit 1
fi

if ((nameonly)); then
    match "${list:-packages}" "$1"
    exit
fi

match "${list:-packages}" "$@" | split | getjson | parse

# vim: set et sw=4 sts=4 ft=sh:
