#!/bin/bash
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -e -o pipefail -o noclobber

argv0=aursync
aurweb=https://aur.archlinux.org
tmp=$(mktemp -dt "$argv0".XXXXXXXXXX)

XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
AURDEST=${AURDEST:-$XDG_CACHE_HOME/$argv0}

readonly PS4 argv0 aurweb tmp XDG_CACHE_HOME AURDEST

declare -i insecure=0 nobuild=0 noversion=0 nodeps=0 nofetch=0
declare -i update=0 ignore=0 snapshot=0 sign=0 rotate=0
declare -i chroot=0 bindro=0 force=0 logdest=0 namcap=0 chtemp=0

viewer() {
    if hash 2>/dev/null vifm; then
        vifm - '+view!'
    else
        command -- "${PAGER:-less}"
    fi
}

inspect() {
    xargs -i find {} -maxdepth "$1" | viewer
}

revcheck() {
    #global aurweb tmp
    git fetch -v

    if ! git remote get-url --all origin | grep -Fq "${aurweb#*//}"; then
        warning "remote does not match ${aurweb#*//}"
    fi

    # git fetch will return 0 even if nothing was fetched.
    if [[ $(git rev-parse HEAD) != $(git rev-parse '@{upstream}') ]]; then
        git --no-pager log --patch --stat '..@{upstream}' >> "$tmp/$1".diff
        git reset --hard HEAD
        git merge
    fi
}

clone() {
    #global aurweb nofetch
    declare base

    while read -r base _; do
        if [[ -d $base/.git ]]; then
            if ! ((nofetch)); then
                GIT_DIR="$base"/.git GIT_WORK_TREE="$base" revcheck "$base"
            fi
        else
            git clone "$aurweb/$base".git
        fi
    done
}

aria() {
    #global aurweb tmp
    awk -v uri="$aurweb" '{printf "%s/%s\n", uri, $2}' | aria2c -d "$tmp" -i -

    for ar in "$tmp"/*.tar.gz; do
        tar xvf "$ar"
    done
}

gendeps() {
    #global print
    if ((nodeps)); then
        printf '%s\n' -- "$@"
    else
        aurchain -a "$@"
    fi
}

ignorepkg() {
    #global ignore
    if ((ignore)); then
        aursift -I
    else
        tee
    fi
}

missing() {
    grep -Fxvf "$1" "$2" | while read -r pkg _; do
        warning "no results found for $pkg"
    done
}

i686() {
    awk -v arch="$(uname -m)" '{
        if(arch == "i686") {
            gsub(/^lib32-/,"")
            gsub(/^gcc-multilib$/,"")
        };  print
    }'
}

getsource() {
    while read -r pkg _; do
        ( cd "$pkg"
          makepkg --verifysource
        )
    done
}

usage() {
    plain "usage: $argv0 [-c] [-B newdir] [-fLnstT] [-u] [--] pkgname..."
    exit 1
}

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}

trap 'trap_exit' EXIT

source /usr/share/makepkg/util.sh

[[ -t 2 ]] && colorize

while getopts :B:cfLnstTu-: OPT; do
    case "$OPT" in
        B|+B) bindro=1
              newdir=$OPTARG ;;
        c|+c) chroot=1       ;;
        f|+f) force=1        ;;
        L|+L) logdest=1      ;;
        n|+n) namcap=1       ;;
        s|+s) sign=1         ;;
        t|+t) snapshot=1     ;;
        T|+T) chtemp=1       ;;
        u|+u) update=1       ;;
        -) case "$OPTARG" in
               chroot)    chroot=1     ;;
               allsrc)    allsrc=1     ;;
               ignore)    ignore=1     ;;
               insecure)  insecure=1   ;;
               nobuild)   nobuild=1    ;;
               nodeps)    nodeps=1     ;;
               nofetch)   nofetch=1    ;;
               noversion) noversion=1  ;;
               sign)      sign=1       ;;
               tar)       snapshot=1   ;;
               update)    update=1     ;;
               allan)     rotate=1     ;;
               repo) repo=${!OPTIND}
                     shift ;;
               *) usage ;;
           esac  ;;
        *) usage ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

if ((rotate)); then
    if { hash rot13 && target=$(aurgrep .+ | shuf -n 1); } 2>/dev/null; then
        exec bash -c "{ \"$argv0\" -cn \"$target\" && repo-elephant; } 2>&1 | rot13"
    else
        echo '?'; exit 16 # EBUSY
    fi
fi

if ! (($# + update)); then
    error "$argv0: no targets specified"
    exit 1
fi

# Set makepkg args in a new list to ensure option context is already
# defined, as getopts parses options sequentially.
if ((chroot)); then
    makepkg_args=(-cu)

    ((bindro))  && makepkg_args+=(-D "$newdir")
    ((chtemp))  && makepkg_args+=(-T)
    ((namcap))  && makepkg_args+=(-n)
else
    makepkg_args=(-crs)

    ((force))   && makepkg_args+=(-f)
    ((logdest)) && makepkg_args+=(-L)
    ((namcap))  && makepkg_args+=(--noconfirm)
fi

if ((chroot)); then
    aurbuild_args+=(-c)
fi

if ((sign)); then
    aurbuild_args+=(-s)
fi

# Only select a repository when building (#127)
if ((!nobuild)) || ((update)); then
    if [[ $repo ]]; then
        read -r root < <(pacconf --single --repo="$repo" Server)
        root=${root#file://}
    else
        read -r repo root < <(repofind -s)
    fi

    # Use a cache directory as package pool (#105)
    if ! grep -qx "$root" <(pacconf CacheDir); then
        error "$argv0: repository root $root is not a cache directory"
        exit 1
    elif [[ ! -d $root ]]; then
        error "$argv0: repository root $root is not a directory"
        exit 20
    elif [[ ! -w $root ]]; then
        error "$argv0: repository root $root is not writeable"
        exit 13
    fi

    msg2 "Using [$repo] repository"
fi

# Reuse selection for repofind (#82)
if ((update)); then
    for p in $(aurcheck -q "$repo"); do
        set -- "$@" "$p"
    done

    if ((!$#)); then
        plain "there is nothing to do"
        exit 0
    fi
fi

mkdir -p "$AURDEST"/snapshot
chmod -c 700 "$AURDEST"

cd_safe "$tmp"
mkdir {aur,sync,tsort}

msg "Resolving dependencies..."
gendeps "$@" | ignorepkg | tee tsort/tree | xargs -r aursearch -Fr > aur/json

jshon -F aur/json -a -e results -a -e Name -u > aur/pkgname
jshon -F aur/json -a -e results -a -e Name -u -p -e PackageBase -u | xargs -n2 > aur/pkgbase
jshon -F aur/json -a -e results -a -e Name -u -p -e Version -u | xargs -n2 > aur/pkgver
jshon -F aur/json -a -e results -a -e PackageBase -u -p -e URLPath -u | xargs -n2 > aur/urlpath

# Include command-line arguments to check for missing packages (#139)
cat <(printf '%s\n' "$@") <(aursift -S < tsort/tree) > foreign

# Warn on packages missing in both official repositories and AUR (#67)
missing aur/pkgname foreign || true

# XXX: Packages without lib32 prefix are not necessarily in the AUR.
grep -Fxf aur/pkgname tsort/tree | i686 | aursplit aur/pkgbase > tsort/pkgbase

if ((!noversion)); then
    # Print updated pkgbase from versioned pairs.
    aursift -U < aur/pkgver | aursplit aur/pkgbase > sync/pkgbase

    # Relative complement: pkgbase (tsort) \ pkgbase (sync)
    if ! grep -Fxvf sync/pkgbase tsort/pkgbase > queue; then
        plain "there is nothing to do"
        exit
    fi
else
    cp -sv tsort/pkgbase queue
fi

msg "Retrieving build files..."

if ((snapshot)); then
    cd_safe "$AURDEST"/snapshot
    grep -Fwf "$tmp"/queue "$tmp"/aur/urlpath | aria
else
    cd_safe "$AURDEST"
    clone < "$tmp"/queue
fi

# View changes and build files in one window (#77)
if ((!insecure)); then
    ( shopt -s nullglob
      printf '%s\n' "$tmp"/*.diff | cat - "$tmp"/queue | inspect 1
    )
fi

if ((allsrc)); then
    getsource < "$tmp"/queue
fi

if ((nobuild)); then
    msg "Sources saved to $PWD"
    exit
fi

aurbuild_args+=(-d "$repo" -r "$root" -p "$root" -a "$tmp"/queue)
aurbuild "${aurbuild_args[@]}" -- "${makepkg_args[@]}"

# vim: set et sw=4 sts=4 ft=sh:
