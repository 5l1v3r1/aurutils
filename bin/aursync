#!/bin/bash
# shellcheck disable=SC2046
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -e -o pipefail -o noclobber

argv0=aursync
aurweb=https://aur.archlinux.org
tmp=$(mktemp -dt "$argv0".XXXXXXXXXX)

XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
AURDEST=${AURDEST:-$XDG_CACHE_HOME/$argv0}

readonly PS4 argv0 aurweb tmp XDG_CACHE_HOME AURDEST

declare -i view=1 build=1 chkver=1 deps=1 fetch=1
declare -i update=0 ignore=0 snapshot=0 sign=0 rotate=0
declare -i chroot=0 bindro=0 force=0 logdest=0 namcap=0 chtemp=0

# $1: origin (URI)
# $2: git fetch (1/0)
# $3: diff directory
# stdin: pkgbase
clone() {
    declare base

    while read -r base _; do
        if [[ -d $base/.git ]]; then
            (($2)) || continue

            ( cd "$base"
              git fetch -v # returns 0 even if nothing was fetched

              if [[ ! $(git remote get-url --all origin) =~ ${1#*//} ]]; then
                  warning "remote does not match ${1#*//}"
              fi

              if [[ $(git rev-parse HEAD) != $(git rev-parse '@{upstream}') ]]; then
                  git --no-pager log --patch --stat '..@{upstream}' >> "$3/$base"
                  git reset --hard HEAD
                  git merge
              fi
            )
        else
            git clone "$1/$base".git
        fi
    done
}

# $1: origin (URI)
# $2: workdir
# stdin: pkgbase
aria() {
    awk -v uri="$1" '{printf "%s/%s\n", uri, $2}' | aria2c -d "$2" -i -

    for ar in "$2"/*.tar.gz; do
        tar xvf "$ar"
    done
}

# $1: tree (1/0)
gendeps() {
    if (($1)); then
        aurchain -a "${@:2}"
    else
        printf -- '%s\n' "${@:2}"
    fi
}

# $1: IgnorePkg (1/0)
# stdin: pkgname
ignorepkg() {
    if (($1)); then
        aursift -I
    else
        tee
    fi
}

# stdin: pkgname
i686() {
    awk -v arch="$(uname -m)" '{
        if(arch == "i686") {
            gsub(/^lib32-/,"")
            gsub(/^gcc-multilib$/,"")
        };  print
    }'
}

viewer() {
    if hash 2>/dev/null vifm; then
        vifm - '+view!'
    else
        command -- "${PAGER:-less}"
    fi
}

inspect() {
    xargs -i find {} -maxdepth "$1" | viewer
}

# stdin: pkgbase
getsource() {
    declare base

    while read -r base _; do
        ( cd "$base"
          makepkg --verifysource
        )
    done
}

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}

usage() {
    plain "usage: $argv0 [-c] [-B newdir] [-fLnstT] [-u] [--] pkgname..."
    exit 1
}

trap 'trap_exit' EXIT
source /usr/share/makepkg/util.sh

if [[ -t 2 ]]; then
    colorize
fi

longopts=allan,allsrc,chroot,help,ignore,nobuild,nodeps,nofetch,nover,noview,sign,tar,update,repo:

if TEMP=$(getopt -o B:cfhLnstTu -l "$longopts" -n "$argv0" -- "$@"); then
    eval set -- "$TEMP"
else
    usage
fi

while true; do
    case "$1" in
        -B|--bind)   bindro=1;
                     newdir=$2;  shift 2 ;;
        -c|--chroot) chroot=1;   shift ;;
        -f|--force)  force=1;    shift ;;
        -L|--log)    logdest=1;  shift ;;
        -n)          namcap=1;   shift ;;
        -s|--sign)   sign=1;     shift ;;
        -T|--temp)   chtemp=1;   shift ;;
        -u|--update) update=1;   shift ;;
        -t|--tar)    snapshot=1; shift ;;
        --allan)     rotate=1;   shift ;;
        --allsrc)    allsrc=1;   shift ;;
        --ignore)    ignore=1;   shift ;;
        --nobuild)   build=0;    shift ;;
        --nodeps)    deps=0;     shift ;;
        --nover)     chkver=0;   shift ;;
        --noview)    view=0;     shift ;;
        --repo)      repo=$2;    shift 2 ;;
        --) shift
            break ;;
        -h|--help)
            usage ;;
    esac
done

if ((rotate)); then
    if { hash rot13 && target=$(aurgrep .+ | shuf -n 1); } 2>/dev/null; then
        exec bash -c "{ \"$argv0\" -cn \"$target\" && repo-elephant; } 2>&1 | rot13"
    else
        echo '?'; exit 16 # EBUSY
    fi
fi

if ! (($# + update)); then
    error "$argv0: no targets specified"
    exit 1
fi

# Set makepkg args in a new list to ensure option context is already
# defined, as getopt parses options from left to right.
if ((chroot)); then
    aurbuild_args+=(-c)
    makepkg_args=(-cu)
    ((bindro))  && makepkg_args+=(-D "$newdir")
    ((chtemp))  && makepkg_args+=(-T)
    ((namcap))  && makepkg_args+=(-n)
else
    makepkg_args=(-crs)
    ((force))   && makepkg_args+=(-f)
    ((logdest)) && makepkg_args+=(-L)
    ((namcap))  && makepkg_args+=(--noconfirm)
fi

if ((sign)); then
    aurbuild_args+=(-s)
fi

if ((build)) || ((update)); then
    if [[ $repo ]]; then
        root=$(repofind -p "$repo")
    else
        dest=$(repofind -s)
        read -r repo root <<< "$dest"
    fi

    if ! grep -qx "$root" <(pacconf CacheDir); then
        error "$argv0: repository path $root is not a cache directory"
        exit 1
    fi

    msg2 "Using [$repo] repository"
fi

if ((update)); then
    set -- "$@" $(aurcheck -q "$repo")

    if ((!$#)); then
        plain "there is nothing to do"
        exit 0
    fi
fi

mkdir -p "$AURDEST"/snapshot
chmod -c 700 "$AURDEST"

cd_safe "$tmp"
mkdir {tsv,json,diff}

msg "Resolving dependencies..."
gendeps "$deps" "$@" | ignorepkg "$ignore" | tee queue_pre | xargs -r aursearch -Fr > json/results

jshon -F json/results -a -e results -a -e Name -u > tsv/pkgname
printf '%s\t%s\n' $(jshon -F json/results -a -e results -a -e Name -u -p -e PackageBase -u)    > tsv/pkgbase
printf '%s\t%s\n' $(jshon -F json/results -a -e results -a -e Name -u -p -e Version -u)        > tsv/pkgver
printf '%s\t%s\n' $(jshon -F json/results -a -e results -a -e PackageBase -u -p -e URLPath -u) > tsv/urlpath

# Include command-line arguments to check for missing packages (#139)
cat <(printf '%s\n' "$@") <(aursift -S < queue_pre) > foreign

if nomatch=($(grep -Fxvf tsv/pkgname foreign)); then
    for pkg in "${nomatch[@]}"; do
        warning "no results found for $pkg"
    done
fi

# XXX: Packages without lib32 prefix are not necessarily in the AUR.
grep -Fxf tsv/pkgname queue_pre | i686 | aursplit tsv/pkgbase > queue_aur

if ((chkver)); then
    # pkgver -> pkgver (sync) -> pkgbase (sync)
    aursift -U < tsv/pkgver | aursplit tsv/pkgbase > updated

    # pkgbase (tsort) \ pkgbase (sync)
    if ! grep -Fxvf updated queue_aur > queue; then
        plain "there is nothing to do"
        exit
    fi
else
    cp -sv queue_aur queue
fi

msg "Retrieving build files..."

if ((snapshot)); then
    cd_safe "$AURDEST"/snapshot
    grep -Fwf "$tmp"/queue "$tmp"/tsv/urlpath | aria "$aurweb" "$tmp"
else
    cd_safe "$AURDEST"
    clone "$aurweb" "$fetch" "$tmp"/diff < "$tmp"/queue
fi

# View changes and build files in one window (#77)
if ((view)); then
    ( shopt -s nullglob
      printf '%s\n' "$tmp"/diff/* | cat - "$tmp"/queue | inspect 1
    )
fi

if ((allsrc)); then
    getsource < "$tmp"/queue
fi

if ((build)); then
    aurbuild_args+=(-d "$repo" -r "$root" -a "$tmp"/queue)
    aurbuild "${aurbuild_args[@]}" -- "${makepkg_args[@]}"
else
    msg "Sources saved to $PWD"
fi

# vim: set et sw=4 sts=4 ft=sh:
