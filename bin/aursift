#!/bin/bash
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
argv0=aursift

readonly PS4 argv0

# Takes a set of package names to create "package virtual" pairs, querying
# both provides and replaces fields.
provides() {
    expac '%n %R %S' -S "$@" | awk '{
        for(i = 2; i <= NF; ++i) { print $1, $i | "sort -u" }
    }'
}

# Read package names from stdin separated by the IFS and produces a list of
# packages not provided in the official repositories.
sift() {
    declare -A pkgset
    declare all siftargs query repo n p r v

    # Use an additional indexed array to preserve input order.
    while read -r p; do
        pkgset["$p"]=1
        all+=("$p")
    done

    if [[ ! ${pkgset[@]} ]]; then
        error "$argv0: no data available"
        exit 61
    fi

    for p in "${!pkgset[@]}"; do
        siftargs+=(--satisfies="$p")
    done

    for r in testing core extra community community-testing multilib multilib-testing; do
        siftargs+=(--repo="$r")
    done

    # Close standard input for pacsift to allow --sync.
    # https://github.com/andrewgregory/pacutils/issues/3
    query=($(pacsift --sync --exact "${siftargs[@]}" <&-))

    if [[ ${query[@]} ]]; then
        for p in "${query[@]#*/}"; do
            if [[ ${pkgset[$p]} ]]; then
                repo+=("$p")
            else
                n+=("$p")
            fi
        done
    else
        msg2 "No matches in the sync database"
    fi

    if [[ ${n[@]} ]]; then
        while read -r p v; do
            if [[ ${pkgset[$v]} ]]; then
                plain "virtual dependency $v provided $p"
                repo+=("$v")
            fi
        done < <(provides "${n[@]}")
    fi

    # Print the relative complement between repo provided dependencies and all
    # required dependencies. all \ repo
    grep -Fxvf <(printf '%s\n' "${repo[@]}") <(printf '%s\n' "${all[@]}")
}

# Read "pkgname pkgver" strings from stdin, find and compare
# repository versions, and print updated packages on stdout.
prepare() {
    declare name ver siftargs check
    declare -A aur repo

    while read -r name ver; do
        aur[$name]=$ver
    done

    if [[ ! ${!aur[@]} ]]; then
        error "$argv0: no data available"
        exit 61
    fi

    while read -r name ver; do
        [[ ! $name ]] && continue

        # If a package is in several repositories, take the newest version. (#105)
        if [[ ${repo[$name]} ]]; then
            case $(vercmp "$ver" "${repo[$name]}") in
                1) repo[$name]=$ver ;;
            esac
        else
            repo[$name]=$ver
        fi
    done < <(expac -S '%n %v' "${!aur[@]}")

    for name in "${!aur[@]}"; do
        if [[ ${repo[$name]} ]]; then
            check=$(vercmp "${repo[$name]}" "${aur[$name]}")
        else
            # vercmp '' foo -> 1, see FS#49093.
            check=-1
        fi

        case "$check" in
            -1) msg2 "$name ${repo[$name]:-0} -> ${aur[$name]}" ;;
            0)  msg "$name is up-to-date"
                printf '%s\n' "$name" ;;
            1)  warning "$name ${repo[$name]:-0} is newer than ${aur[$name]}"
                printf '%s\n' "$name" ;;
        esac
    done
}

ignore() {
    declare p q
    declare -A ign

    while read -r p; do
        ign[$p]=1
    done < <(pacconf IgnorePkg)

    while read -r q; do
        if [[ ${ign[$q]} ]]; then
            warning "$q: ignoring package upgrade"
        else
            printf '%s\n' "$q"
        fi
    done
}

source /usr/share/makepkg/util.sh || exit

if [[ -t 2 ]]; then
    colorize
fi

while getopts :ISU OPT; do
    case $OPT in
        I) ignore  ;;
        S) sift    ;;
        U) prepare ;;
        *) plain "usage: $argv0 [-IS pkgname] [-U pkgname pkgver]"
           exit 1 ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

# vim: set et sw=4 sts=4 ft=sh:
