#!/bin/bash
readonly argv0=aurcheck
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -o pipefail

declare -i geq=0 ver=1 cmp=0
declare    mode=aur

# Optimize for the common case (version equality)
my_vercmp() {
    declare -r v_in=$1 v_cmp=$2

    if [[ $v_cmp ]]; then
        if [[ $v_in != "$v_cmp" ]]; then
            vercmp "$v_in" "$v_cmp"
        else
            printf '%d' 0
        fi
    else
        printf '%d' 2
    fi
}

sort_join() {
    sort -k 1b,1 -- "$1" | join -a 1 - <(sort -k 1b,1 -- "$2")
}

cmp_equal_or_newer() {
    sort_join "$1" "$2" | while read -r pkg v_in v_cmp _; do
        op=$(my_vercmp "$v_in" "$v_cmp")

        case $op in
            -1) plain "$pkg $v_cmp is newer than $v_in"
                printf -- '%s\n' "$pkg"     ;;
             0) printf -- '%s\n' "$pkg"     ;;
             1) msg2 "$pkg $v_cmp -> $v_in" ;;
             2) msg2 "$pkg N/A -> $v_in"    ;;
        esac
    done
}

cmp_all() {
    sort_join "$1" "$2" | while read -r pkg v_in v_cmp _; do
        op=$(my_vercmp "$v_in" "$v_cmp")

        if ((op == 2 && geq < 2)) || ((op > -1 && !geq)); then
            continue
        fi

        if ((!ver)); then
            printf '%s\n' "$pkg"
        else
            case "$op" in
                -1) printf -- '%s %s -> %s\n' "$pkg" "$v_in" "$v_cmp" ;;
                 0) printf -- '%s %s = %s\n'  "$pkg" "$v_in" "$v_cmp" ;;
                 1) printf -- '%s %s <- %s\n' "$pkg" "$v_in" "$v_cmp" ;;
                 2) printf -- '%s (not available)' "$pkg" ;;
            esac
        fi
    done
}

namever_aur() {
    xargs -r aursearch -ir | jq -er '.results[] | [.Name,.Version] | @tsv'
}

namever_sync() {
    # pacsift does not error if the repo is not configured
    pacconf --repo="$database" >/dev/null || return 1

    # Use --exact as repos may have a common substring (#166)
    pacsift --exact --repo="$1" --null <&- | xargs -0r pacman -Sddp --print-format '%n %v'
}

repo_list() {
    bsdcat "$1" | awk '/%NAME%/    {getline; printf("%s\t", $1)}
                       /%VERSION%/ {getline; printf("%s\n", $1)}'
}

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}

usage() {
    plain "usage: $argv0 [-aclq] [-d repository] [-r root]"
    exit 1
}

readonly -f my_vercmp sort_join cmp_equal_or_newer cmp_all \
         namever_aur namever_sync repo_list trap_exit usage

source /usr/share/makepkg/util.sh || exit

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

unset database root
while getopts :acd:lqr: OPT; do
    case $OPT in
        a) ((geq++))        ;;
        q) ver=0            ;;
        d) database=$OPTARG ;;
        c) mode=repo; cmp=1 ;;
        l) mode=repo; cmp=0 ;;
        r) root=$OPTARG     ;;
        *) usage            ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

tmp=$(mktemp -dt "$argv0".XXXXXXXX) || exit
trap 'trap_exit' EXIT

case $mode in
    aur)
        if [[ -v database ]]; then
            namever_sync "$database" >"$tmp"/db || exit
        else
            tee "$tmp"/db
        fi

        if awk '{print $1}' "$tmp"/db | namever_aur >"$tmp"/aur; then
            cmp_all "$tmp"/db "$tmp"/aur
        fi
        ;;
    repo)
        if [[ -v database ]]; then
            server=$(pacconf --single --repo="$database" Server) || exit
            server=${server#*://}
        else
            error "$argv0: no repository specified"
            exit 1
        fi

        repo_list "${root-$server}/$database".db >"$tmp"/db || exit

        if ((cmp)); then
            cmp_equal_or_newer /dev/stdin "$tmp"/db
        else
            column -t "$tmp"/db
        fi
esac

# vim: set et sw=4 sts=4 ft=sh:
