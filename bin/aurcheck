#!/bin/bash
readonly argv0=aurcheck
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -o pipefail

declare -i geq=0 mode=0 ver=1

# As this function is called from inner loops in repo_*, optimize for
# the common case (version equality)
my_vercmp() {
    if [[ $1 != "$2" ]]; then
        vercmp "$1" "$2"
    else
        printf '%d' '0'
    fi
}

namever() {
    jq -er '.results[] | [.Name,.Version] | @tsv'
}

syncver() {
    # Use --exact as repos may have a common substring (#166)
    pacsift --exact --repo="$1" --null <&- | xargs -0r pacman -Sddp --print-format '%n %v'
}

repo_list() {
    bsdcat "$1" | awk '/%NAME%/    {getline; printf("%s\t", $1)}
                       /%VERSION%/ {getline; printf("%s\n", $1)}'
}

sort_join() {
    sort -k 1b,1 -- "$1" | join -a 1 - <(sort -k 1b,1 -- "$2")
}

cmp_equal_or_newer() {
    sort_join "$1" "$2" | while read -r pkg v_in v_cmp _; do
        if [[ $v_cmp ]]; then
            op=$(my_vercmp "$v_in" "$v_cmp")
        else
            op=2
        fi

        case $op in
            -1) plain "$pkg $v_cmp is newer than $v_in"
                printf -- '%s\n' "$pkg"     ;;
             0) printf -- '%s\n' "$pkg"     ;;
             1) msg2 "$pkg $v_cmp -> $v_in" ;;
             2) msg2 "$pkg N/A -> $v_in"    ;;
        esac
    done
}

cmp_all() {
    sort_join "$1" "$2" | while read -r pkg v_in v_cmp _; do
        if [[ $v_cmp ]]; then
            op=$(my_vercmp "$v_in" "$v_cmp")
        else
            op=2
        fi

        if ((op == 2 && geq < 2)) || ((op > -1 && !geq)); then
            continue
        fi

        if ((!ver)); then
            printf '%s\n' "$pkg"
        else
            case "$op" in
                -1) printf -- '%s %s -> %s\n' "$pkg" "$v_in" "$v_cmp" ;;
                 0) printf -- '%s %s = %s\n'  "$pkg" "$v_in" "$v_cmp" ;;
                 1) printf -- '%s %s <- %s\n' "$pkg" "$v_in" "$v_cmp" ;;
                 2) printf -- '%s (not available)' "$pkg" ;;
            esac
        fi
    done
}

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}

usage() {
    plain "usage: $argv0 [-aclq] [-d repository] [-r root]"
    exit 1
}

readonly -f my_vercmp namever syncver sort_join repo_list \
          cmp_equal_or_newer cmp_all trap_exit usage

source /usr/share/makepkg/util.sh || exit

if [[ -t 2 ]] && [[ ! -o xtrace ]]; then
    colorize
fi

unset db root
while getopts :acd:lqr: OPT; do
    case $OPT in
        a) ((geq++))    ;;
        q) ver=0        ;;
        d) db=$OPTARG
           mode=1       ;;
        c) mode=2       ;;
        l) mode=3       ;;
        r) root=$OPTARG ;;
        *) usage        ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

tmp=$(mktemp -dt "$argv0".XXXXXXXX) || exit
trap 'trap_exit' EXIT

case $mode in
    0)
        tee "$tmp"/db | awk '{print $1}' > "$tmp"/pkg
        xargs -a "$tmp"/pkg -r aursearch -ir | namever > "$tmp"/aur
        cmp_all "$tmp"/db "$tmp"/aur ;;
    1)
        syncver "$db" | tee "$tmp"/db | awk '{print $1}' > "$tmp"/pkg
        xargs -a "$tmp"/pkg -r aursearch -ir | namever > "$tmp"/aur
        cmp_all "$tmp"/db "$tmp"/aur ;;
    2)
        root=${root-$(pacconf --single --repo="$db" Server)} || exit
        repo_list "${root#*://}/$db".db > "$tmp"/db
        cmp_equal_or_newer /dev/stdin "$tmp"/db ;;
    3)
        root=${root-$(pacconf --single --repo="$db" Server)} || exit
        repo_list "${root#*://}/$db".db ;;
esac

# vim: set et sw=4 sts=4 ft=sh:
