#!/bin/bash
set -e

readonly argv0=aurbuild
readonly basedir=$PWD
readonly PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

machine=$(uname -m)
readonly machine

declare -a gpg_args=(--detach-sign --no-armor --verbose --batch)
declare -a makechrootpkg_args=(-cu) makepkg_args=(-rs) repo_add_args=()
declare -i chroot=0 sign_pkg=0 overwrite=0 no_sync=0 sign_pkg=0

conf_section() {
    printf '[%s]\n' "$1"
    pacconf --raw "${@:2}"
}

conf_devtools() {
    conf_section options --config="$1" --options
    printf '#CacheDir=\n'

    pacconf --repo-list | while IFS= read -r; do
        conf_section "$REPLY" --repo="$REPLY"
    done
}

conf_local() {
    conf_section options --options
    conf_section "$1" --repo="$1"
}

db_replaces() {
    bsdcat "$1" | awk '/%REPLACES%/ {
        while(NF != 0) {getline; print}
    }'
}

find_pkg_dupes() {
    xargs -I{} find "$1" -name '{}*' | grep -Exv '.+(~|_namcap\.log|\.part)$' -
}

canonicalize_path_ro() {
    readlink -env -- "$1" || return

    if ! [[ -r $1 ]]; then
        error "$argv0: $1: permission denied (read-only)"
        return 13
    fi
}

canonicalize_path_rw() {
    readlink -env -- "$1" || return

    if ! [[ -r $1 && -w $1 ]]; then
        error "$argv0: $1: permission denied (read-write)"
        return 13
    fi
}

trap_exit() {
    if ! [[ -o xtrace ]]; then
        rm -rf "$tmp" "$var_tmp"
    fi
}

usage() {
    plain "usage: $argv0 -d database [-acCfMNPrs] [--] <makepkg args>"
    exit 1
}

readonly -f conf_section conf_devtools conf_local db_replaces find_pkg_dupes
readonly -f canonicalize_path_ro canonicalize_path_rw trap_exit usage

source /usr/share/makepkg/util.sh

if [[ -t 2 && ! -o xtrace ]]; then
    colorize
fi

unset container makepkg_conf pacman_conf root queue database
while getopts a:cC:d:fMNPr:s OPT; do
    case $OPT in
        C) container=$(canonicalize_path_ro "$OPTARG")    ;;
        M) makepkg_conf=$(canonicalize_path_ro "$OPTARG") ;;
        P) pacman_conf=$(canonicalize_path_ro "$OPTARG")  ;;
        r) root=$(canonicalize_path_rw "$OPTARG")         ;;
        a) queue=$OPTARG    ;;
        d) database=$OPTARG ;;
        c) chroot=1         ;;
        f) overwrite=1      ;;
        N) no_sync=1        ;;
        s) sign_pkg=1       ;;
        *) usage ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

if [[ -v database ]]; then
    server=$(pacconf --single --repo="$database" Server)
else
    error "$argv0: database: missing argument"
    usage
fi

if ! [[ -v root ]]; then
    root=$(canonicalize_path_rw "${server#*://}")
fi

db_path=$(canonicalize_path_rw "$root/$database".db)

readonly database server root db_path queue chroot overwrite no_sync sign_pkg
readonly container=${container-/var/lib/aurbuild}/$machine
readonly makepkg_conf=${makepkg_conf-/usr/share/devtools/makepkg-$machine.conf}
readonly pacman_conf=${pacman_conf-/usr/share/devtools/pacman-extra.conf}

if [[ -v queue ]]; then
    exec {fd}< "$queue"
else
    exec {fd}< <(printf '\n')
fi

# Reset option array if arguments are specified after --
if (($#)); then
    if ((chroot)); then
        makechrootpkg_args=("$@")
    else
        makepkg_args=("$@")
    fi
fi

if command -v xdelta3 >/dev/null; then
    repo_add_args+=(-d)
fi

if ((sign_pkg)); then
    repo_add_args+=(-v -s)

elif [[ -f $db_path.sig ]]; then
    error "$argv0: signature found, but signing is disabled"
    printf >&2 -- '%q\n' "$db_path".sig; exit 1
fi

if [[ -v GPGKEY ]] && gpg --list-keys "$GPGKEY"; then
    gpg_args+=(-u "$GPGKEY")
fi

tmp=$(mktemp -d "${TMPDIR:-/tmp}/$argv0".XXXXXXXX)
var_tmp=$(mktemp -d "${TMPDIR:-/var/tmp}/$argv0".XXXXXXXX)

readonly makechrootpkg_args makepkg_args repo_add_args gpg_args tmp var_tmp
trap 'trap_exit' EXIT
trap 'exit' INT

if ((chroot)); then
    conf_devtools "$pacman_conf" > "$tmp"/pacman.conf

    if [[ -f $container/root/.arch-chroot ]]; then
        sudo arch-nspawn -C "$tmp"/pacman.conf -M "$makepkg_conf" \
            "$container"/root pacman -Syu --noconfirm
    else
        sudo install -d "$container" -m 755 -v
        sudo mkarchroot  -C "$tmp"/pacman.conf -M "$makepkg_conf" \
             "$container"/root base-devel
    fi

    # Check if target repository is configured in chroot (#161)
    pacconf --root="$container"/root --repo="$database" >/dev/null
else
    conf_local "$database" > "$tmp"/custom.conf
fi

while read -r -u "$fd" pkg _; do
    cd_safe "$basedir/$pkg"

    if ((!overwrite)); then
        mapfile -t mark < <(makepkg --packagelist | find_pkg_dupes "$root")

        if [[ ${mark[*]} ]]; then
            warning "$argv0: skipping built package (use -f to overwrite)"
            printf >&2 -- '%q\n' "${mark[@]}"; continue
        fi
    fi

    if ((chroot)); then
        sudo PKGDEST="$var_tmp" makechrootpkg \
            -d "$root" -r "$container" "${makechrootpkg_args[@]}"
    else
        PKGDEST="$var_tmp" LC_MESSAGES=C makepkg "${makepkg_args[@]}"
    fi

    # fixed by: https://git.archlinux.org/pacman.git/commit/?id=c0a5884b
    find "$basedir/$pkg" -type l -xtype f -lname "$var_tmp*" -delete

    cd_safe "$var_tmp"
    pkglist=(./*)

    if ((sign_pkg)); then
        for p in "${pkglist[@]}"; do
            gpg "${gpg_args[@]}" --output "$p".sig "$p"
            mv -b "$p" "$p".sig -t "$root"
        done
    else
        mv -b "${pkglist[@]}" -t "$root"
    fi

    cd_safe "$root"
    LANG=C repo-add "${repo_add_args[@]}" "$db_path" "${pkglist[@]}"

    if ((chroot)) || ((no_sync)); then
        continue
    else
        replaces=$(grep -Fxf <(db_replaces "$db_path") <(pacman -Qq) | paste -s -d, -)

        sudo pacman -Fy  --config="$tmp"/custom.conf
        sudo pacman -Syu --config="$tmp"/custom.conf --ignore="$replaces" --noconfirm
    fi
done

exec {fd}<&-

# vim: set et sw=4 sts=4 ft=sh:
