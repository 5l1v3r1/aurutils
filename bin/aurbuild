#!/bin/bash
# -*- indent-tabs-mode: nil; -*-
PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
set -e

argv0=aurbuild
base=$PWD
tmp=$(mktemp -dt "$argv0".XXXXXXXXXX)

readonly PS4 argv0 base tmp
declare -i chroot=0 sign_pkg=0

makepkg_args=(-Lcrs)
makechrootpkg_args=(-cu)
repose_args=(-vf)

build_local() {
    #global database pool root makepkg_args repose_args sign_pkg
    if ((sign_pkg)); then
        makepkg_args+=(--sign)
    fi

    PKGDEST="$pool" LC_MESSAGES=C makepkg "${makepkg_args[@]}"
    LANG=C repose "${repose_args[@]}" "$database" -r "$root" -p "$pool"

    printf '%s\n%s\n' "[$database]" "$(pacconf --repo="$database")" > "$tmp"/config
    sudo pacman -Syu --config="$tmp"/config --noprogressbar
}

build_chroot() {
    #global HOME GNUPGHOME GPGKEY container pool root makechrootpkg_args repose_args database
    declare p gpgargs

    # Preserve PKGDEST for makechrootpkg (#120)
    sudo PKGDEST="$pool" makechrootpkg -d "$pool" -d "$root" -r "$container" "${makechrootpkg_args[@]}"

    # As pinentry relies on GPG_TTY and DISPLAY, sign packages outside the chroot. (#130)
    if ((sign_pkg)); then
        gpgargs=(--verbose --detach-sign --no-armor)

        if [[ $GPGKEY ]]; then
            gpgargs+=(-u "$GPGKEY")
        fi

        for p in $(makepkg --packagelist); do
            find "$pool" -type f -regex ".+/$p.pkg.+?" -execdir gpg "${gpgargs[@]}" {} \;
        done
    fi

    LANG=C repose "${repose_args[@]}" "$database" -r "$root" -p "$pool"
}

trap_exit() {
    if [[ ! -o xtrace ]]; then
        rm -rf "$tmp"
    fi
}

usage() {
    plain "usage: $argv0 [-cs] -a <queue> -d <repo> -r <root> [-p <pool>] [--] ARGS"
}

trap 'exit' INT
trap 'trap_exit' EXIT
source /usr/share/makepkg/util.sh

if [[ -t 2 ]]; then
    colorize
fi

while getopts a:cd:m:p:r:s OPT; do
    case $OPT in
        a) queue=$OPTARG ;;
        c) chroot=1 ;;
        d) database=$OPTARG ;;
        m) machine=$OPTARG ;;
        p) pool=$OPTARG ;;
        r) root=$OPTARG ;;
        s) repose_args+=(--sign)
           sign_pkg=1 ;;
        *) usage; exit 1 ;;
    esac
done
shift $((OPTIND - 1))
OPTIND=1

# Reset option array if arguments are specified after --
if (($#)); then
    if ((chroot)); then
        makechrootpkg_args=("$@")
    else
        makepkg_args=("$@")
    fi
fi

if [[ -z ${!database} ]]; then
    error "$argv0: database: missing argument"
    usage; exit 1
elif ! pacconf --repo="$database" >/dev/null; then
    exit 22
fi

if [[ -z ${!queue} ]]; then
    error "$argv0: queue: missing argument"
    usage; exit 1
elif [[ ! -r $queue || -d $queue ]]; then
    error "$argv0: queue: must be a readable file"
    exit 13
fi

if [[ $root ]]; then
    root=$(realpath -e -- "$root")
else
    root=$(repofind -p "$database")
fi

if [[ $pool ]]; then
    pool=$(realpath -e -- "$pool")
else
    pool=$root
fi

if ((chroot)); then
    machine=${machine:-$(uname -m)}
    pacconf --raw > "$tmp"/pacman.conf

    if ! grep -qx "$machine" <(setarch --list); then
        error "$argv0: $machine: unknown architecture"
        exit 38
    else
        container=/var/lib/aurbuild/$machine
        repose_args+=(-m "$machine")
    fi
    
    if [[ ! -d $container ]]; then
        sudo install -d "$container"
        sudo setarch "$machine" mkarchroot -C "$tmp"/pacman.conf "$container"/root base base-devel
    else
        sudo arch-nspawn "$container"/root pacman -Syu --noconfirm
    fi
fi

# Read from FD 3 to choose providers with makepkg (#21)
exec 3< "$queue"

while read -r -u 3 pkg _; do
    if cd "$base/$pkg"; then
        if ((chroot)); then
            build_chroot
        else
            build_local
        fi
    fi
done

exec 3<&-

# vim: set et sw=4 sts=4 ft=sh:
